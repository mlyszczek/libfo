#!/usr/bin/env python3
## ==========================================================================
#   Licensed under BSD 2clause license See LICENSE file for more information
#   Author: Michał Łyszczek <michal.lyszczek@bofc.pl>
## ==========================================================================

# prefix used to search for default db, can be changed during install step,
# by default it is set to "/usr/local", which is default install directory
# for most manually installed packages.
prefix = "/usr/local"

## ==========================================================================
#                   _                                 __
#                  (_)____ ___   ____   ____   _____ / /_ _____
#                 / // __ `__ \ / __ \ / __ \ / ___// __// ___/
#                / // / / / / // /_/ // /_/ // /   / /_ (__  )
#               /_//_/ /_/ /_// .___/ \____//_/    \__//____/
#                            /_/
## ==========================================================================


import	argparse
import	csv
import	errno
import	os
import	pprint
import	re
import	sys

from	string import Template


## ==========================================================================
#               ____                     __   _
#              / __/__  __ ____   _____ / /_ (_)____   ____   _____
#             / /_ / / / // __ \ / ___// __// // __ \ / __ \ / ___/
#            / __// /_/ // / / // /__ / /_ / // /_/ // / / /(__  )
#           /_/   \__,_//_/ /_/ \___/ \__//_/ \____//_/ /_//____/
#
## ==========================================================================


## ==========================================================================
#   Prints message to standard error
## ==========================================================================


def eprint(
	*args,
	**kwargs
):
	print(*args, file=sys.stderr, **kwargs)


## ==========================================================================
#                                 __                __
#                          _____ / /_ ____ _ _____ / /_
#                         / ___// __// __ `// ___// __/
#                        (__  )/ /_ / /_/ // /   / /_
#                       /____/ \__/ \__,_//_/    \__/
#
## ==========================================================================


    ## ==================================================================
    #            __       __                      __   __
    #        ___/ /___ _ / /_ ___ _  ___ _ ___ _ / /_ / /  ___  ____
    #       / _  // _ `// __// _ `/ / _ `// _ `// __// _ \/ -_)/ __/
    #       \_,_/ \_,_/ \__/ \_,_/  \_, / \_,_/ \__//_//_/\__//_/
    #                              /___/
    ## ==================================================================


# read arguments to get data about config to generate

parser = argparse.ArgumentParser(description="Generate fo.{c,h} files")
parser.add_argument("-d", "--db", required=0, metavar="file",
		help="Path to a csv database file with functions information " + \
				"that can be used to generage fo.c file. If not passed " + \
				"default db will be used")
parser.add_argument("-o", "--output", required=0, metavar="name",
		help="set output filename (without extension), if not specified " + \
				"fo will be used to generate fo.c and fo.h files")
parser.add_argument("-l", "--list", required=0, metavar="file",
		help="new-line separated list of function to generate fo.c file " + \
				"with, if not specified, all functions from db will be " + \
				"generated")
parser.add_argument("-r", "--res-dir", required=0, metavar="path",
		help="Path to custom resource directory")
args = parser.parse_args()


resdir = prefix + "/share/fogen"
# if system directory does not exist (ie. progen was not
# installed and is runs directly from source directory, use
# resources where script is located
if not os.path.isdir(resdir):
	resdir = os.path.dirname(os.path.realpath(__file__))
if args.res_dir:
	resdir = args.res_dir

db_path = resdir + "/db.conf"
if args.db:
	db_path = args.db

outc = "fo.c"
outh = "fo.h"
if args.output:
	outc = args.output + ".c"
	outh = args.output + ".h"

flist = ""
if args.list:
	flist = args.list

eprint("fogen - starting")
eprint("functions database file..: " + db_path)
eprint("output files.............: " + outc + ", " + outh)
eprint("function list file.......: " + \
		("none, generate all from db" if len(flist) == 0 else flist))
eprint("resource directory.......: " + resdir)

dbc = ""
with open(db_path) as file:
	for line in file:
		if line.startswith("#") or len(line) == 0:
			continue
		dbc += line

db = []
dbt = dict()
dbt = [row for row in csv.DictReader(dbc.splitlines(), skipinitialspace=1)]

if len(flist) == 0:
    db = dbt
else:
    with open(flist) as fl:
        for opt in dbt:
            fl.seek(0)
            for f in fl.read().splitlines():
                if f == opt['fname']:
                    db.append(opt)
                    break


    ## ==================================================================
    #                                   __                   __        __
    #  ___ _ ___  ___  ___  ____ ___ _ / /_ ___   ___ __ __ / /   ___ / /_
    # / _ `// -_)/ _ \/ -_)/ __// _ `// __// -_) (_-</ // // _ \ (_-</ __/
    # \_, / \__//_//_/\__//_/   \_,_/ \__/ \__/ /___/\_,_//_.__//___/\__/
    #/___/
    ## ==================================================================
    #   Now generate substitutions so they can be later use to replace
    #   placeholders in fo.{c,h}.in files.
    ## ==================================================================


## ==========================================================================
#   ${include_list}
#
#   like:
#       #include <stdlib.h>
#       #include <stdio.h>
#       #include <unistd.h>
## ==========================================================================


headers = ["ctype.h", "dlfcn.h", "errno.h", "stdint.h", "stdio.h", "stdlib.h",
		"string.h"]
for f in db:
	for h in f['headers'].split(";"):
		headers.append(h.strip())

# remove duplicates
headers = list(set(headers))

include_list = ""
for h in headers:
	include_list += "#include <" + h + ">\n"


## ==========================================================================
#    ${fo_init_list}
#    ${fo_enum_list}
#
#    like:
#        FO_INIT(setsockopt);
#        FO_INIT(read);
#        FO_INIT(close);
## ==========================================================================


fo_init_list = ""
fo_enum_list = ""
for f in db:
	fo_init_list += "\tFO_INIT({});\n".format(f['fname'])
	fo_enum_list += "\tfo_{},\n".format(f['fname'])


## ==========================================================================
#   ${fo_overrides}
#
#   all overriden functions
## ==========================================================================


o = ""
for f in db:
	o += "{} {}\n(\n".format(f['rtype'], f['fname'])

	i = 0
	args = ""       # <type> <name> args in function decl
	types = ""      # types for function pointer decl <type1>, <type2>, ...
	args_call = ""  # args in call: arg1, arg2, arg3, ...
	for t in f['args'].split(";"):
		t = t.strip()
		args += "\t{} arg{},\n".format(t, i)
		types += "{}, ".format(t)
		args_call += "arg{}, ".format(i)
		i += 1

	# strip last commas
	args = args[:-2]
	types = types[:-2]
	args_call = args_call[:-2]

	o += args + "\n)\n{\n"
	o += "\tif (fo_info[fo_{}].countdown == -1 ||\n".format(f['fname'])
	o += "\t\t\t--(fo_info[fo_{}].countdown) != 0)\n".format(f['fname'])
	o += "\t{\n"
	o += "\t\t{} (*original)({});\n".format(f['rtype'], types)
	o += "\t\toriginal = fo_info[fo_{}].original;\n".format(f['fname'])
	o += "\t\treturn original({});\n".format(args_call)
	o += "\t}\n"
	o += "\terrno = fo_info[fo_{}].errn;\n".format(f['fname'])
	o += "\treturn ({})fo_info[fo_{}].ret;\n".format(f['rtype'], f['fname'])
	o += "}\n\n\n"

fo_overrides = o[:-3] # strip trailing new lines


    ## ==================================================================
    #           __                     __       __   _
    #          / /_ ___  __ _   ___   / /___ _ / /_ (_)___  ___ _
    #         / __// -_)/  ' \ / _ \ / // _ `// __// // _ \/ _ `/
    #         \__/ \__//_/_/_// .__//_/ \_,_/ \__//_//_//_/\_, /
    #                        /_/                          /___/
    ## ==================================================================
    #   Now that all templates are prepared, we can replace data in
    #   `.in' files with generated ones.
    ## ==================================================================


with open(resdir + "/fo.c.in") as file_in, open(outc, "w") as file_out:
	d = dict()

	# create dict with all substitutions
	d['include_list'] = include_list
	d['fo_init_list'] = fo_init_list
	d['fo_overrides'] = fo_overrides

	# and replace all
	file_out.write(Template(file_in.read()).substitute(d))


with open(resdir + "/fo.h.in") as file_in, open(outh, "w") as file_out:
	d = dict()

	# create dict with all substitution
	d['fo_enum_list'] = fo_enum_list

	# and replace all
	file_out.write(Template(file_in.read()).substitute(d))
