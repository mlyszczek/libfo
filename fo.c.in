/* ==========================================================================
    Licensed under BSD 2clause license See LICENSE file for more information
    Author: Michał Łyszczek <michal.lyszczek@bofc.pl>
   ==========================================================================
    This file has been generated by fogen from https://libfo.bofc.pl/
   ==========================================================================
          _               __            __         ____ _  __
         (_)____   _____ / /__  __ ____/ /___     / __/(_)/ /___   _____
        / // __ \ / ___// // / / // __  // _ \   / /_ / // // _ \ / ___/
       / // / / // /__ / // /_/ // /_/ //  __/  / __// // //  __/(__  )
      /_//_/ /_/ \___//_/ \__,_/ \__,_/ \___/  /_/  /_//_/ \___//____/

   ========================================================================== */


#ifndef _GNU_SOURCE
#define _GNU_SOURCE 1
#endif

#include "fo.h"

${include_list}


/* ==========================================================================
          __             __                     __   _
     ____/ /___   _____ / /____ _ _____ ____ _ / /_ (_)____   ____   _____
    / __  // _ \ / ___// // __ `// ___// __ `// __// // __ \ / __ \ / ___/
   / /_/ //  __// /__ / // /_/ // /   / /_/ // /_ / // /_/ // / / /(__  )
   \__,_/ \___/ \___//_/ \__,_//_/    \__,_/ \__//_/ \____//_/ /_//____/

   ========================================================================== */

/* return -1 and set errno to e, when expression x fails (is 0) */
#define VALID(e, x) if (!(x)) { errno = (e); return -1; }

/* struct holding information about single function override */
struct fo_info
{
	/* when set and reaches 0, fo will call spoofed function to
	 * trigger error condition. Check description of fo_fail()
	 * function for more details
	 */
	int  countdown;

	/* value to return when spoofed function is called */
	intptr_t  ret;

	/* errno to set when spoofed function is called */
	int  errn;

	/* pointer to original function */
	void  *original;

	/* string representation of function */
	const char  *str;
};

/* array of all functions information */
static struct fo_info fo_info[fo_f_max];


/* ==========================================================================
                ____                     __   _
               / __/__  __ ____   _____ / /_ (_)____   ____   _____
              / /_ / / / // __ \ / ___// __// // __ \ / __ \ / ___/
             / __// /_/ // / / // /__ / /_ / // /_/ // / / /(__  )
            /_/   \__,_//_/ /_/ \___/ \__//_/ \____//_/ /_//____/

   ========================================================================== */


/* ==========================================================================
    Function searches for errno int value from string. This is to allow
    writing string errno value in init file.
   ========================================================================== */


static int errno_str_to_int
(
	const char  *s
)
{
	     if (strcmp(s, "EPERM") == 0) return EPERM;
	else if (strcmp(s, "ENOENT") == 0) return ENOENT;
	else if (strcmp(s, "ESRCH") == 0) return ESRCH;
	else if (strcmp(s, "EINTR") == 0) return EINTR;
	else if (strcmp(s, "EIO") == 0) return EIO;
	else if (strcmp(s, "ENXIO") == 0) return ENXIO;
	else if (strcmp(s, "E2BIG") == 0) return E2BIG;
	else if (strcmp(s, "ENOEXEC") == 0) return ENOEXEC;
	else if (strcmp(s, "EBADF") == 0) return EBADF;
	else if (strcmp(s, "ECHILD") == 0) return ECHILD;
	else if (strcmp(s, "EAGAIN") == 0) return EAGAIN;
	else if (strcmp(s, "ENOMEM") == 0) return ENOMEM;
	else if (strcmp(s, "EACCES") == 0) return EACCES;
	else if (strcmp(s, "EFAULT") == 0) return EFAULT;
	else if (strcmp(s, "ENOTBLK") == 0) return ENOTBLK;
	else if (strcmp(s, "EBUSY") == 0) return EBUSY;
	else if (strcmp(s, "EEXIST") == 0) return EEXIST;
	else if (strcmp(s, "EXDEV") == 0) return EXDEV;
	else if (strcmp(s, "ENODEV") == 0) return ENODEV;
	else if (strcmp(s, "ENOTDIR") == 0) return ENOTDIR;
	else if (strcmp(s, "EISDIR") == 0) return EISDIR;
	else if (strcmp(s, "EINVAL") == 0) return EINVAL;
	else if (strcmp(s, "ENFILE") == 0) return ENFILE;
	else if (strcmp(s, "EMFILE") == 0) return EMFILE;
	else if (strcmp(s, "ENOTTY") == 0) return ENOTTY;
	else if (strcmp(s, "ETXTBSY") == 0) return ETXTBSY;
	else if (strcmp(s, "EFBIG") == 0) return EFBIG;
	else if (strcmp(s, "ENOSPC") == 0) return ENOSPC;
	else if (strcmp(s, "ESPIPE") == 0) return ESPIPE;
	else if (strcmp(s, "EROFS") == 0) return EROFS;
	else if (strcmp(s, "EMLINK") == 0) return EMLINK;
	else if (strcmp(s, "EPIPE") == 0) return EPIPE;
	else if (strcmp(s, "EDOM") == 0) return EDOM;
	else if (strcmp(s, "ERANGE") == 0) return ERANGE;
	else if (strcmp(s, "EDEADLK") == 0) return EDEADLK;
	else if (strcmp(s, "ENAMETOOLONG") == 0) return ENAMETOOLONG;
	else if (strcmp(s, "ENOLCK") == 0) return ENOLCK;
	else if (strcmp(s, "ENOSYS") == 0) return ENOSYS;
	else if (strcmp(s, "ENOTEMPTY") == 0) return ENOTEMPTY;
	else if (strcmp(s, "ELOOP") == 0) return ELOOP;
	else if (strcmp(s, "EWOULDBLOCK") == 0) return EWOULDBLOCK;
	else if (strcmp(s, "ENOMSG") == 0) return ENOMSG;
	else if (strcmp(s, "EIDRM") == 0) return EIDRM;
	else if (strcmp(s, "ECHRNG") == 0) return ECHRNG;
	else if (strcmp(s, "EL2NSYNC") == 0) return EL2NSYNC;
	else if (strcmp(s, "EL3HLT") == 0) return EL3HLT;
	else if (strcmp(s, "EL3RST") == 0) return EL3RST;
	else if (strcmp(s, "ELNRNG") == 0) return ELNRNG;
	else if (strcmp(s, "EUNATCH") == 0) return EUNATCH;
	else if (strcmp(s, "ENOCSI") == 0) return ENOCSI;
	else if (strcmp(s, "EL2HLT") == 0) return EL2HLT;
	else if (strcmp(s, "EBADE") == 0) return EBADE;
	else if (strcmp(s, "EBADR") == 0) return EBADR;
	else if (strcmp(s, "EXFULL") == 0) return EXFULL;
	else if (strcmp(s, "ENOANO") == 0) return ENOANO;
	else if (strcmp(s, "EBADRQC") == 0) return EBADRQC;
	else if (strcmp(s, "EBADSLT") == 0) return EBADSLT;
	else if (strcmp(s, "EDEADLOCK") == 0) return EDEADLOCK;
	else if (strcmp(s, "EBFONT") == 0) return EBFONT;
	else if (strcmp(s, "ENOSTR") == 0) return ENOSTR;
	else if (strcmp(s, "ENODATA") == 0) return ENODATA;
	else if (strcmp(s, "ETIME") == 0) return ETIME;
	else if (strcmp(s, "ENOSR") == 0) return ENOSR;
	else if (strcmp(s, "ENONET") == 0) return ENONET;
	else if (strcmp(s, "ENOPKG") == 0) return ENOPKG;
	else if (strcmp(s, "EREMOTE") == 0) return EREMOTE;
	else if (strcmp(s, "ENOLINK") == 0) return ENOLINK;
	else if (strcmp(s, "EADV") == 0) return EADV;
	else if (strcmp(s, "ESRMNT") == 0) return ESRMNT;
	else if (strcmp(s, "ECOMM") == 0) return ECOMM;
	else if (strcmp(s, "EPROTO") == 0) return EPROTO;
	else if (strcmp(s, "EMULTIHOP") == 0) return EMULTIHOP;
	else if (strcmp(s, "EDOTDOT") == 0) return EDOTDOT;
	else if (strcmp(s, "EBADMSG") == 0) return EBADMSG;
	else if (strcmp(s, "EOVERFLOW") == 0) return EOVERFLOW;
	else if (strcmp(s, "ENOTUNIQ") == 0) return ENOTUNIQ;
	else if (strcmp(s, "EBADFD") == 0) return EBADFD;
	else if (strcmp(s, "EREMCHG") == 0) return EREMCHG;
	else if (strcmp(s, "ELIBACC") == 0) return ELIBACC;
	else if (strcmp(s, "ELIBBAD") == 0) return ELIBBAD;
	else if (strcmp(s, "ELIBSCN") == 0) return ELIBSCN;
	else if (strcmp(s, "ELIBMAX") == 0) return ELIBMAX;
	else if (strcmp(s, "ELIBEXEC") == 0) return ELIBEXEC;
	else if (strcmp(s, "EILSEQ") == 0) return EILSEQ;
	else if (strcmp(s, "ERESTART") == 0) return ERESTART;
	else if (strcmp(s, "ESTRPIPE") == 0) return ESTRPIPE;
	else if (strcmp(s, "EUSERS") == 0) return EUSERS;
	else if (strcmp(s, "ENOTSOCK") == 0) return ENOTSOCK;
	else if (strcmp(s, "EDESTADDRREQ") == 0) return EDESTADDRREQ;
	else if (strcmp(s, "EMSGSIZE") == 0) return EMSGSIZE;
	else if (strcmp(s, "EPROTOTYPE") == 0) return EPROTOTYPE;
	else if (strcmp(s, "ENOPROTOOPT") == 0) return ENOPROTOOPT;
	else if (strcmp(s, "EPROTONOSUPPORT") == 0) return EPROTONOSUPPORT;
	else if (strcmp(s, "ESOCKTNOSUPPORT") == 0) return ESOCKTNOSUPPORT;
	else if (strcmp(s, "EOPNOTSUPP") == 0) return EOPNOTSUPP;
	else if (strcmp(s, "EPFNOSUPPORT") == 0) return EPFNOSUPPORT;
	else if (strcmp(s, "EAFNOSUPPORT") == 0) return EAFNOSUPPORT;
	else if (strcmp(s, "EADDRINUSE") == 0) return EADDRINUSE;
	else if (strcmp(s, "EADDRNOTAVAIL") == 0) return EADDRNOTAVAIL;
	else if (strcmp(s, "ENETDOWN") == 0) return ENETDOWN;
	else if (strcmp(s, "ENETUNREACH") == 0) return ENETUNREACH;
	else if (strcmp(s, "ENETRESET") == 0) return ENETRESET;
	else if (strcmp(s, "ECONNABORTED") == 0) return ECONNABORTED;
	else if (strcmp(s, "ECONNRESET") == 0) return ECONNRESET;
	else if (strcmp(s, "ENOBUFS") == 0) return ENOBUFS;
	else if (strcmp(s, "EISCONN") == 0) return EISCONN;
	else if (strcmp(s, "ENOTCONN") == 0) return ENOTCONN;
	else if (strcmp(s, "ESHUTDOWN") == 0) return ESHUTDOWN;
	else if (strcmp(s, "ETOOMANYREFS") == 0) return ETOOMANYREFS;
	else if (strcmp(s, "ETIMEDOUT") == 0) return ETIMEDOUT;
	else if (strcmp(s, "ECONNREFUSED") == 0) return ECONNREFUSED;
	else if (strcmp(s, "EHOSTDOWN") == 0) return EHOSTDOWN;
	else if (strcmp(s, "EHOSTUNREACH") == 0) return EHOSTUNREACH;
	else if (strcmp(s, "EALREADY") == 0) return EALREADY;
	else if (strcmp(s, "EINPROGRESS") == 0) return EINPROGRESS;
	else if (strcmp(s, "ESTALE") == 0) return ESTALE;
	else if (strcmp(s, "EUCLEAN") == 0) return EUCLEAN;
	else if (strcmp(s, "ENOTNAM") == 0) return ENOTNAM;
	else if (strcmp(s, "ENAVAIL") == 0) return ENAVAIL;
	else if (strcmp(s, "EISNAM") == 0) return EISNAM;
	else if (strcmp(s, "EREMOTEIO") == 0) return EREMOTEIO;
	else if (strcmp(s, "EDQUOT") == 0) return EDQUOT;
	else if (strcmp(s, "ENOMEDIUM") == 0) return ENOMEDIUM;
	else if (strcmp(s, "EMEDIUMTYPE") == 0) return EMEDIUMTYPE;
	else if (strcmp(s, "ECANCELED") == 0) return ECANCELED;
	else if (strcmp(s, "ENOKEY") == 0) return ENOKEY;
	else if (strcmp(s, "EKEYEXPIRED") == 0) return EKEYEXPIRED;
	else if (strcmp(s, "EKEYREVOKED") == 0) return EKEYREVOKED;
	else if (strcmp(s, "EKEYREJECTED") == 0) return EKEYREJECTED;
	else if (strcmp(s, "EOWNERDEAD") == 0) return EOWNERDEAD;
	else if (strcmp(s, "ENOTRECOVERABLE") == 0) return ENOTRECOVERABLE;
	else if (strcmp(s, "ERFKILL") == 0) return ERFKILL;
	else if (strcmp(s, "EHWPOISON") == 0) return EHWPOISON;
	return 0;
}


/* ==========================================================================
                       __     __ _          ____
        ____   __  __ / /_   / /(_)_____   / __/__  __ ____   _____ _____
       / __ \ / / / // __ \ / // // ___/  / /_ / / / // __ \ / ___// ___/
      / /_/ // /_/ // /_/ // // // /__   / __// /_/ // / / // /__ (__  )
     / .___/ \__,_//_.___//_//_/ \___/  /_/   \__,_//_/ /_/ \___//____/
    /_/
   ========================================================================== */


/* ==========================================================================
    Initializes function override object. Should be called at least once
    before any call to overrided function or else it will behave undefined,
    and will probably trigger segfault (or much worse). It's best to call it
    as first function in you test code - just right after main() {.

    It can be called twice and more, in such case object's state will be
    reseted and any configured failing points won't work after this is
    called again (original function will be called, not overriden one).

    Function does not return anything, when error occurs, exit() is called,
    since it's pointless to continue execution when original function we
    are overriding does not exist.
   ========================================================================== */


void fo_init
(
	void
)
{
	const char  *init_file;  /* optional file used to load failing points */
	char         line[256];  /* single line from init_file */
	FILE        *f;          /* init_file stdio handle */
	/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

	#define die(S, ...) do { fprintf(stderr, S, __VA_ARGS__); exit(1); } while (0)
	#define diep(S) do { perror(S); exit(1); } while (0)

	#define FO_INIT(F) \
		fo_info[fo_ ## F].countdown = -1; \
		fo_info[fo_ ## F].ret = 0; \
		fo_info[fo_ ## F].errn = 0; \
		fo_info[fo_ ## F].original = dlsym(RTLD_NEXT, #F); \
		fo_info[fo_ ## F].str = #F; \
		if (fo_info[fo_ ## F].original == NULL) \
		{ \
			fprintf(stderr, "f/dlsym(RTLD_NEXT, %s): %s\n", #F, dlerror()); \
			exit(1); \
		}

${fo_init_list}

	if ((init_file = getenv("LIBFO_INIT_FILE")) == NULL)
		return;

	if ((f = fopen(init_file, "r")) == NULL)
		die("error opening init-file %s: %s\n", init_file, strerror(errno));

	for (;;)
	{
		char  ret[32];        /* return value part from csv */
		char  errn[32];       /* errno part from csv */
		char  function[256];  /* function part from csv */
		char  countdown[32];  /* countdown part from csv */
		char *l;              /* pointer to line[] buf for easy manipulation */
		int   pos;            /* general position indicator */
		int   fo_pos;         /* function position in array */
		/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


		l = line;
		line[sizeof(line) - 1] = 0x7f;
		memset(ret, 0x00, sizeof(ret));
		memset(errn, 0x00, sizeof(errn));
		memset(function, 0x00, sizeof(function));
		memset(countdown, 0x00, sizeof(countdown));

		if (fgets(line, sizeof(line), f) == NULL)
		{
			int ret = feof(f);
			fclose(f);

			if (ret)
				return;
			die("fgets() on %s failed: %s\n", init_file, strerror(errno));
		}

		if (line[sizeof(line) - 1] == '\0' && line[sizeof(line) - 2] != '\n')
			die("line too long, max is: %zu?!\n", sizeof(line) - 1);

		/* parse csv file, ignoring leading whitespaces */
		while (isspace(*l)) ++l;
		for (pos = 0; *l != ',' && *l != '\0'; function[pos++] = *l++);
		while (isspace(*l) || *l == ',') ++l;
		for (pos = 0; *l != ',' && *l != '\0'; countdown[pos++] = *l++);
		while (isspace(*l) || *l == ',') ++l;
		for (pos = 0; *l != ',' && *l != '\0'; ret[pos++] = *l++);
		while (isspace(*l) || *l == ',') ++l;
		for (pos = 0; *l != ',' && *l != '\0'; errn[pos++] = *l++);
		errn[pos - 1] = '\0'; /* remove last \n */

		for (pos = 0; pos != fo_f_max; ++pos)
		{
			if (strcmp(fo_info[pos].str, function))
				continue;

			fo_pos = pos;
			break;
		}

		fo_info[fo_pos].countdown = atoi(countdown);
		fo_info[fo_pos].errn = errno_str_to_int(errn);
		fo_info[fo_pos].ret = strcmp(ret, "NULL") ? atol(ret) : FO_NULL;
	}
}


/* ==========================================================================
    Configures point of failure for specified function.

    (doc assumes posix function write() has been overriden)

    params
        function
            Must be taken from 'enum fo_f' as this is used as array index.
            Those enum values are in format fo_function-name. So to install
            write() failure, you'd use fo_write as function argument.

        countdown
            Each time you call overriden function (like write()), your
            program will actually call write() defined in this file. If you
            just initialized fo, then countdown will be '-1' and our write()
            will call real posix write() function. You can use this function
            to trigger error on posix call function. To do so, you need to
            set countdown to value 1 or bigger. Each time our write() is
            called, countdown will get decremented and once it reaches 0,
            our write() will return value ret and set errno to value errn.

            So to make write() to fail on first call (after fo_fail() call),
            you need to set countdown to 1. When you set countdown to -
            let's say 3 - then first and second write() will call real posix
            write() but 3rd call to write() will return ret value with errno
            set to errn.

        ret
            this value will be returned when countdown reaches 0 and fo will
            trigger error condition.

        errn
            this value will be stored to errno when countdown reaches 0 and
            fo will trigger error condition.

    errno
        ENOENT
            function does not exist in the list of overriden functions

        EINVAL
            countdown is less than 0
   ========================================================================== */


int fo_fail
(
	int       function,    /* function to override */
	int       countdown,   /* after how many calls trigger error */
	intptr_t  ret,         /* value to return upon error */
	int       errn         /* errno to be set upon error */
)
{
	VALID(ENOENT, function < fo_f_max);
	VALID(EINVAL, countdown >= 0);

	fo_info[function].countdown = countdown;
	fo_info[function].ret = ret;
	fo_info[function].errn = errn;
	return 0;
}


/* ==========================================================================
                                              _      __
              ____  _   __ ___   _____ _____ (_)____/ /___   _____
             / __ \| | / // _ \ / ___// ___// // __  // _ \ / ___/
            / /_/ /| |/ //  __// /   / /   / // /_/ //  __/(__  )
            \____/ |___/ \___//_/   /_/   /_/ \__,_/ \___//____/

   ========================================================================== */


${fo_overrides}
